<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="author" content="Claire Wagner (Summer 2022 Wheaton College Research Team)">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Map of City-Owned Properties</title>

  <!-- Leaflet CDN -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css"
    integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ=="
    crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"
    integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ=="
    crossorigin=""></script>

  <!-- Leaflet.markercluster CDN -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css"
    integrity="sha512-RLEjtaFGdC4iQMJDbMzim/dOvAu+8Qp9sw7QE4wIMYcg2goVoivzwgSZq9CsIxp4xKAZPKh5J2f2lOko2Ze6FQ=="
    crossorigin=""/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css"
    integrity="sha512-BBToHPBStgMiw0lD4AtkRIZmdndhB6aQbXpX7omcrXeG2PauGBl2lzq2xUZTxaLxYz5IDHlmneCZ1IJ+P3kYtQ=="
    crossorigin=""/>
  <!-- minified -->
  <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"
    integrity="sha512-MQlyPV+ol2lp4KodaU/Xmrn+txc1TP15pOBF/2Sfre7MRsA/pB4Vy58bEqe9u7a7DczMLtU5wT8n7OblJepKbg=="
    crossorigin=""></script>

  <!-- Leaflet.FeatureGroup.SubGroup CDN -->
  <script src="https://unpkg.com/leaflet.featuregroup.subgroup@1.0.2/dist/leaflet.featuregroup.subgroup.js"
    integrity="sha512-gUiI5CXREIHHGko8AdlPYADT5MHvcCuqee1pjKR4qVcw69zVI+WvrnJcCxwU8JajpJoBjpvPIAGfDVFoQJhDfw=="
    crossorigin=""></script>

  <!-- External files for data -->
  <script src="data.js"></script>
  <script src="ward_boundaries_sp34-6z76.js"></script>
  
  <style>

    .formDiv {
      margin: 10px;
    }

    .validInput {
      background-color: null;
    }

    .invalidInput {
      background-color: pink;
    }

    .center {
      text-align: center;
    }

    .increasedLineHeight {
      line-height: 1.5;
    }

    .message {
      margin: 3px;
    }

    #map {
      width: 100%;
      height: 600px;
      left: 0;
      top: 0;
    }

    #pageHeader {
      text-align: center;
      font-size: 12px;
    }

    #mapDescription {
      font-style: italic;
    }

    #sgmRadiusInput {
      width: 3.5em;
    }

    #pinSearchInput {
      width: 12em;
    }

  </style>
    
</head>

<body>

  <div id="pageHeader">
    <h1>Map of City-Owned Properties</h1>
  </div>

  <p id="mapDescription"></p-->

  <div id="exportSavedPinsForm" class="formDiv">
    <button type="button" id="exportSavedPinsButton">
      Export Saved PINs
    </button>
    <span id="exportSavedPinsMessage" class="message"></span>
  </div>

  <div id="pinSearchForm" class="formDiv">
    <label>
      Search for city-owned PIN on map:
      <input type="text" id="pinSearchInput" class="validInput"/>
    </label>
    <button type="button" id="pinSearchButton">
      Search
    </button>
    <span id="pinSearchMessage" class="message"></span>
  </div>

  <div id="sgmRadiusForm" class="formDiv">
    <label>
      Set radius of circle around Sunshine Gospel Ministries (in kilometers):
      <input type="number" id="sgmRadiusInput" class="validInput"/>
    </label>
    <button type="button" id="sgmRadiusSetButton">
      Set Radius
    </button>
    <span id="sgmRadiusMessage" class="message"></span>
  </div>

  <div id="map"></div>

  <script>

    // create map
    const map = L.map("map", {
      center: [41.783, -87.621],
      zoom: 13,
      scrollWheelZoom: false,
      doubleClickZoom: false,
    });

    // add tiles to map - reference: https://leafletjs.com/examples/layers-control/
    const osmtiles = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; <a href='http://www.openstreetmap.org/copyright'>OpenStreetMap</a>"
    }).addTo(map);
      
    /**
     * Generate a custom icon with the specified fill color.
     * The icon is based on https://commons.wikimedia.org/wiki/File:Octicons-location.svg (MIT license).
     * Resources referenced: https://onestepcode.com/leaflet-markers-svg-icons/.
     * @param color The fill color.
     * @returns The custom icon with the specified fill color.
     */
    function generateIcon(color) {
      const width = 24;
      const height = 48;
      return L.divIcon({
        className: "custom_divicon",
        iconSize: [width, height],
        iconAnchor: [width/2, height],
        popupAnchor: [0,-(height/5)*4],
        html:
          `<svg
            width="${width}"
            height="${height}"
            viewBox="0 0 640 1024"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M320 0c-177 0-320 143-320 320s160 416 320 704c160-288 320-527 320-704s-143-320-320-320z m0 448c-71 0-128-57-128-128s57-128 128-128 128 57 128 128-57 128-128 128z"
              fill=${color}
              stroke=black
              stroke-width=10px
            />
          </svg>`
      });
    };

    /* Create ward boundary layers */
    const geoJSONLayers = new Map();
    
    function addGeoJSONLayer(key, label, color, layer) {
      geoJSONLayers.set(key, {
        layer: layer,
        label: label,
        color: color,
      });
    };
       
    /* Function to be run for each ward feature */
    const onEachWard = (feature, layer) => {
      if (feature.properties && feature.properties.ward) {
        layer.bindPopup("Ward " + feature.properties.ward);
      }
    };
    
    let ward20Feature = null;

    // Add ward boundaries layer
    if (wardBoundaries) {
      addGeoJSONLayer("wardBoundaries", "Ward Boundaries", "black", L.geoJSON(
        wardBoundaries,
        {
          style: {
            color: "black",
            weight: 2,
            fillOpacity: 0,
          },
          onEachFeature: (feature, layer) => {
            onEachWard(feature, layer);
            // Add shaded layer for Ward 20
            if (feature.properties && feature.properties.ward === "20") {
              ward20Feature = feature;
            }
          }
        }
      ));
    }

    // Add Ward 20 fill
    if (ward20Feature) {
      const ward20FillColor = "#e9ac3c";
      addGeoJSONLayer("ward20Fill", "Ward 20 (shaded)", ward20FillColor, L.geoJSON(
        ward20Feature,
        {
          style: {
            color: "black",
            weight: 2,
            fillColor: ward20FillColor,
            fillOpacity: 0.4,
          },
          onEachFeature: onEachWard,
        }
      ));
    }

    const parentMarkerCluster = L.markerClusterGroup({
      maxClusterRadius: 50,
    }).addTo(map);

    // map of marker layers
    const markerLayers = new Map();

    /**
     * Helper function to add a new marker layer to markerLayers.
     * @param key The key for the map entry.
     * @param label The label to associate with the marker layer.
     * @param color The color to associate with the marker layer.
     * @param useCluster Whether or not to use marker clustering with this marker layer. 
     */
    function addMarkerLayer(key, label, color, useCluster) {
      markerLayers.set(key, {
        layer: useCluster ? L.featureGroup.subGroup(parentMarkerCluster) : L.layerGroup(),
        label: label,
        color: color,
        markerCount: 0,
      });
    }

    /**
     * Add a marker to the specified marker layer.
     * @param layerName The name of the marker layer (used as a key to get the layer from
     * markerLayers).
     * @param data An object containing the data for the marker (must include latitude and
     * longitude properties).
     * @param popupContent The content for the marker popup.
     * @return The marker.
     * Postcondition: The marker has been added to the specified marker layer and the marker
     * property for that layer has been incremented by one. The "marker" property of the data
     * object now points to the marker, and the "layerName" property of the data object now
     * holds the layer name.
     */
    function addMarker(layerName, data, popupContent) {
      const markerLayer = markerLayers.get(layerName);
      const marker = L.marker([data.latitude, data.longitude], {
        icon: generateIcon(markerLayer.color),
      })
        .bindPopup(popupContent)
        .addTo(markerLayer.layer);
      markerLayer.markerCount++;
      data.marker = marker;
      data.layerName = layerName;
    }

        /**
     * Helper function to display a message to the user.
     * @param destination The element where the message should be displayed.
     * @param message The message to display.
     * @param color The color for the message.
     */
     function displayMessage(destination, message, color) {
      destination.style.color = color;
      destination.innerText = message;
    }


    /**
     * Helper function to download data as file.
     * Based on https://stackoverflow.com/a/30832210 (CC BY-SA 3.0 license).
     * @param data The data to include in the file.
     * @param filename The name of the file to download.
     * @param type The MIME type of the data.
     */
     function downloadDataAsFile(data, filename, type) {
      const file = new Blob([data], {type: type});
      const downloadLink = document.createElement("a");
      const url = URL.createObjectURL(file);
      downloadLink.href = url;
      downloadLink.download = filename;
      downloadLink.click();
      setTimeout(function() {
        URL.revokeObjectURL(url);  
      }, 0);
    }

    /**
     * Helper function to export saved pins as JSON.
     * @param filename The name of the exported JSON.
     */
    function exportSavedPins(filename) {
      // which fields to include in the exported data
      const fieldsToExport = [
        "pin",
        "property_address",
        "property_zip",
        "ward",
        "sq_ft",
        "property_status",
        "managing_organization",
        "date_of_acquisition",
        "date_of_disposition",
        "last_update",
        "tract_geoid",
        "latitude",
        "longitude",
      ];
      // create JSON
      let counter = 0;
      let toExport = "[";
      savedPins.forEach((pin) => {
        toExport += JSON.stringify(data[pin], fieldsToExport);
        toExport += (counter++ < savedPins.size-1) ? "," : "";
      });
      toExport += "]";
      // download JSON
      downloadDataAsFile(toExport, `${exportFileName}`, "/application/json");
    }

    // set of pins saved by user
    const savedPins = new Set();

    function getMarkerPopupContent(pin, data) {
      // display info about pin
      const dataDisplay = document.createElement("p");
      dataDisplay.setAttribute("class", "increasedLineHeight");
      dataDisplay.innerHTML = [
        `PIN: ${pin}`,
        `Address: ${data.property_address}`,
        `Zip Code: ${data.property_zip}`,
        `Ward: ${data.ward}`,
        `Property Status: ${data.property_status}`,
        `Record Last Updated: ${data['last_update_aksk-kvfp']}`,
        `Property Details: <a href="https://www.cookcountyassessor.com/pin/${pin}" target="_blank" rel="noopener">Assessor's Office</a>`
      ].join("<br>");
      // allow user to add or remove pin from saved pins
      const savedPinButton = document.createElement("button");
      savedPinButton.setAttribute("type", "button");
      savedPinButton.innerText = "Add to Saved PINs";
      savedPinButton.addEventListener("click", (event) => {
        if (savedPins.has(pin)) {
          // remove pin from saved pins
          savedPins.delete(pin);
          savedPinButton.innerText = "Add to Saved PINs";
        } else {
          // add pin to saved pins
          savedPins.add(pin);
          savedPinButton.innerText = "Remove from Saved PINs";
        }
      });
      // center savedPinButton
      const savedPinButtonDiv = document.createElement("div");
      savedPinButtonDiv.setAttribute("class", "center");
      savedPinButtonDiv.appendChild(savedPinButton);
      // return div with dataDisplay and savedPinButton
      const popupDiv = document.createElement("div");
      popupDiv.appendChild(dataDisplay);
      popupDiv.appendChild(savedPinButtonDiv);
      return popupDiv;
    }

    // add marker layers
    addMarkerLayer("ward20", "City-Owned PINs in Ward 20", "#0000ff", true);
    addMarkerLayer("otherWards", "City-Owned PINs in Other Wards", "#9900cc", true);
    addMarkerLayer("sunshineGospel", "Sunshine Gospel Ministries", "#ff0000", false);
    addMarkerLayer("sunshineGospelCircle", "Circle around Sunshine Gospel Ministries", "#ff0000", false);

    // add marker for Sunshine Gospel Ministries
    addMarker(
      "sunshineGospel",
      sunshineGospel,
      "<a href='https://www.sunshinegospel.org/' target='_blank' rel='noopener'>Sunshine Gospel Ministries</a>"
    );
    
    // add circle of ~2 mi. radius centered at Sunshine Gospel Ministries
    const sgmCircle = L.circle([sunshineGospel.latitude, sunshineGospel.longitude], {
      radius: 3000,
      color: markerLayers.get("sunshineGospelCircle").color,
      fillOpacity: 0.15,
    }).addTo(markerLayers.get("sunshineGospelCircle").layer);

    // add city-owned PINs to map
    for (const pin of Object.keys(data)) {
      const datum = data[pin];
      const layerKey = (datum.ward > 0 && datum.ward <= 50)
        ? (datum.ward === 20) ? "ward20" : "otherWards"
        : null;
      if (!layerKey) {
        console.log(`Error: the PIN ${pin} could not be categorized.`);
      } else {
        addMarker(
          layerKey,
          datum,
          getMarkerPopupContent(pin, datum),
        );
      }
    }

    // add layer control
    const layerControl = L.control.layers(
      {
        "OpenStreetMap" : osmtiles,
      },
      null,
      {
        collapsed : true,
        hideSingleBase : true,
      }
    ).addTo(map);

    /**
     * Helper function to add all overlays in the specified Map data structure to the map and the map's layer control.
    */
    function addOverlaysToMap(overlayMap) {
      // Helper function to generate the label for a layer
      function getOverlayLabel(layerInfo) {
        // include the layer color and name in the overlay label
        let label = `<span style='color: ${layerInfo.color}'>&#9724;</span> ${layerInfo.label}`;
        // if the layer has a marker count greater than zero, include it in the overlay label
        if (layerInfo.markerCount && layerInfo.markerCount > 0) {
          label += ` (${layerInfo.markerCount} marker${layerInfo.markerCount > 1 ? "s" : ""})`;
        }
        return label;
      }
      // add each overlay in overlayMap to the map and the map's layer control
      for (const overlay of overlayMap.values()) {
        layerControl.addOverlay(
          overlay.layer,
          getOverlayLabel(overlay),
        );
        overlay.layer.addTo(map);
      }

    }

    // Add overlays to map and map layer control
    addOverlaysToMap(markerLayers);
    addOverlaysToMap(geoJSONLayers);

    // allow the user to change the radius of sgmCircle
    const sgmRadiusInput = document.getElementById("sgmRadiusInput");
    const sgmRadiusMessage = document.getElementById("sgmRadiusMessage");
    sgmRadiusInput.value = sgmCircle.getRadius() / 1000; // meters to kilometers
    document.getElementById("sgmRadiusSetButton").addEventListener("click", (event) => {
      const newRadius = parseFloat(sgmRadiusInput.value);
      if (!isNaN(newRadius)) {
        // valid float
        sgmCircle.setRadius(newRadius * 1000); // kilometers to meters
        const sgmCircleLayer = markerLayers.get("sunshineGospelCircle").layer;
        if (!map.hasLayer(sgmCircleLayer)) {
          sgmCircleLayer.addTo(map);
        }
        sgmRadiusInput.classList.replace("invalidInput", "validInput");
        displayMessage(sgmRadiusMessage, `Success! The radius has been set to ${newRadius} km.`, "green");
      } else {
        // invalid float
        sgmRadiusInput.classList.replace("validInput", "invalidInput");
        displayMessage(sgmRadiusMessage, "Error: input must be a valid number.", "red");
      }
    });

    // allow the user to zoom in on an inputted PIN
    const pinSearchInput = document.getElementById("pinSearchInput");
    const pinSearchMessage = document.getElementById("pinSearchMessage");
    document.getElementById("pinSearchButton").addEventListener("click", (event) => {
      // try to find PIN in list of city-owned PINs (ignoring '-' characters)
      const pin = pinSearchInput.value.replace(/-/g,'');
      const pinData = data[pin];
      if (pinData) {
        // if the PIN was found, zoom in, alert the user, and open the PIN's marker popup
        const pinLayer = markerLayers.get(pinData.layerName).layer;
        if (!map.hasLayer(pinLayer)) {
          pinLayer.addTo(map);
        }
        parentMarkerCluster.zoomToShowLayer(
          pinData.marker,
          () => {
            pinSearchInput.classList.replace("invalidInput", "validInput");
            displayMessage(pinSearchMessage, "Success! The results for your search have been displayed on the map.", "green");
            pinData.marker.openPopup();
          },
        );
      } else {
        // if the PIN could not be found, alert the user
        pinSearchInput.classList.replace("validInput", "invalidInput");
        displayMessage(pinSearchMessage, "Error: the inputted PIN could not be found on the map.", "red");
      }
    });

    // allow user to export saved pins
    const exportSavedPinsMessage = document.getElementById("exportSavedPinsMessage");
    const exportFileName = "saved_pins.json";
    document.getElementById("exportSavedPinsButton").addEventListener("click", (event) => {
      if (savedPins.size > 0) {
        exportSavedPins(exportFileName);
        displayMessage(exportSavedPinsMessage, `Success! The saved PINs have been exported as "${exportFileName}".`, "green");
      } else {
        displayMessage(exportSavedPinsMessage, "There are no saved PINs to export. You can save a PIN by clicking on its marker on the map and selecting \"Add to Saved PINs\".", "red");
      }
    });

    // add map description
    document.getElementById("mapDescription").innerHTML = "This is a map of properties owned by the "
      + "City of Chicago that may be for sale and of interest to Sunshine Gospel Ministries' Housing "
      + "Equity Initiative. The data for this map comes from the Chicago Data Portal's "
      + `<a href="https://data.cityofchicago.org/Community-Economic-Development/City-Owned-Land-Inventory/aksk-kvfp" target="_blank" rel="noopener">City-Owned Land Inventory dataset</a>`
      + " and Cook County's "
      + `<a href="https://datacatalog.cookcountyil.gov/Property-Taxation/Assessor-Archived-05-11-2022-Property-Locations/c49d-89sn" target="_blank" rel="noopener">Property Locations dataset</a>`
      + ` (accessed on ${accessDateTime}). Click on each marker to view more information about the `
      + "property it represents.";

  </script>   

</body>

</html>

<!-- references:
  https://github.com/Leaflet/Leaflet/tree/main/docs/examples (BSD 2-Clause license)
  https://github.com/Leaflet/Leaflet.markercluster (MIT license)
  https://github.com/ghybs/Leaflet.FeatureGroup.SubGroup (BSD 2-Clause license)
-->

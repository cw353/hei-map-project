<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Editable Map</title>

  <!-- Leaflet CDN -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css"
    integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ=="
    crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"
    integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ=="
    crossorigin=""></script>
  <script src="helper_functions.js"></script>

  <style>
    #map {
      position: relative;
      width: 100%;
      height: 500px;
      left: 0;
      top: 0;
    }

    .flexColumn {
      display: flex;
      flex-direction: column;
    }

    .flexRow {
      display: flex;
      flex-direction: row;
    }

    button {
      margin: 5px;
      border-color: grey;
      background-color: lightgrey;
      border-style: solid;
    }

    button:hover {
      color: #eeffff;
      background-color: grey;
    }

    .globalButtonDiv {
      margin: 10px;
    }

    .warning {
      background-color: #fc617b;
    }

    .warning:hover {
      background-color: #fd4b68;
      border-color: #fd4b68;
    }

    .defaultOption {
      background-color: #82aaff;
    }

    .defaultOption:hover {
      background-color: #4e85fb;
      border-color: #4e85fb;
    }

    .iconButton {
      border-width: 0px;
      background-color: transparent;
    }

    .iconButton:hover {
      background-color: lightgrey;
    }

    .floatRight {
      float: right;
    }

    .unsaved {
      color: #fc617b;
      text-align: center;
    }

    .textAlignCenter {
      text-align: center;
      align-items: center;
    }

  </style>
    
</head>

<body>

  <div id="globalButtonDiv" class="globalButtonDiv flexRow">
    <button type="button">
      Import Markers
    </button>
    <button type="button">
      Export Markers
    </button>
    <button type="button">
      Delete Markers
    </button>
  </div>

  <div id="map"></div>

  <div id="editCategoryDiv"></div>

  <script>

    // create map
    const map = L.map("map", {
      center: [41.783, -87.621],
      zoom: 5,
    });

    // add tiles to map
    const osmtiles = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "Â© OpenStreetMap"
    }).addTo(map);

    // data structure to track markerRecords
    const markerRecords = new Map();

    // create marker layer
    const markerLayerGroup = L.layerGroup().addTo(map);
    const markerLayerGroup2 = L.layerGroup().addTo(map);

    function hasMarkerRecord(recordKey) {
      for (const key of markerRecords.keys()) {
        if (markerRecords.get(key).has(recordKey)) {
          return true;
        }
      }
      return false;
    }

    function getMarkerRecord(recordKey) {
      for (const key of markerRecords.keys()) {
        if (markerRecords.get(key).has(recordKey)) {
          return markerRecords.get(key).get(recordKey);
        }
      }
      return null;
    }

    function setMarkerRecord(categoryName, recordKey, recordValue) {
      if (!(markerRecords.has(categoryName))) {
        markerRecords.set(categoryName, new Map());
      }
      markerRecords.get(categoryName).set(recordKey, recordValue);
      return markerRecords.get(categoryName).get(recordKey);
    }

    function deleteMarkerRecord(categoryName, recordKey) {
      if (markerRecords.has(categoryName)) {
        const toDelete = markerRecords.get(categoryName).get(recordKey);
        markerRecords.get(categoryName).delete(recordKey);
        return toDelete;
      }
      return null;
    }

    const categories = new Map([
      ["Unsorted", { color: "#0000ff" }], // blue
      ["Vacant Lots", { color: "#ff0000" }], // red
      ["Houses", { color: "#00ff00" }], // green
    ]);

    const editCategoryElements = [];

    const layerControl = L.control.layers(
      {
        "OpenStreetMap" : osmtiles,
      },
      null,
      {
        sortLayers : true,
        //hideSingleBase : true,
      },
    ).addTo(map);

    categories.forEach((categoryInfo, categoryName) => {
      const layerGroup = L.layerGroup().addTo(map);
      categoryInfo.layerGroup = layerGroup;
      if (categoryName !== "Unsorted") layerControl.addOverlay(layerGroup, categoryName);
    });

    categories.forEach((categoryInfo, categoryName) => editCategoryElements.push(createElement({
      tag: "p",
      attributes: [["class", "flexRow textAlignCenter"]],
      children: [
        createElement({
          tag: "label",
          text: "Category: ",
          children: [ createElement({
            tag: "input",
            attributes: [["type", "text"], ["value", categoryName]],
          }) ],
        }),
        createElement({
          /*tag: "label",
          text: "Color: ",
          children: [ createElement({*/
            tag: "input",
            attributes: [["type", "color"], ["value", categoryInfo.color]],
          //}) ],
        }),
        createElement({
          tag: "button",
          text: "Apply Changes",
          attributes: [["type", "button"]],
        })
      ],
    })));

    document.getElementById("editCategoryDiv").appendChild(createElement({
      tag: "form",
      children: editCategoryElements,
    }));
    
    /**
     * Generate a custom icon with the specified fill color.
     * The icon is based on https://commons.wikimedia.org/wiki/File:Octicons-location.svg (MIT license).
     * Resources referenced: https://onestepcode.com/leaflet-markers-svg-icons/.
     * @param color The fill color.
     * @returns The custom icon with the specified fill color.
     */
     function generateIcon(color) {
      const width = 24;
      const height = 48;
      return L.divIcon({
        className: "custom_divicon",
        iconSize: [width, height],
        iconAnchor: [width/2, height],
        popupAnchor: [0,-(height/5)*4],
        html:
          `<svg
            width="${width}"
            height="${height}"
            viewBox="0 0 640 1024"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M320 0c-177 0-320 143-320 320s160 416 320 704c160-288 320-527 320-704s-143-320-320-320z m0 448c-71 0-128-57-128-128s57-128 128-128 128 57 128 128-57 128-128 128z"
              fill=${color}
              stroke=black
              stroke-width=10px
            />
          </svg>`
      });
    }

    function updateMarkerPopupContent(marker, newContent) {
      marker.closePopup();
      marker.setPopupContent(newContent);
    }

    function getEditMarkerUI(latlng) {

      // !!! account for case where marker doesn't yet exist?
      const latlngString = JSON.stringify(latlng);
      let markerRecord = getMarkerRecord(latlngString);

      const labelInput = createElement({
        tag: "input",
        attributes: [
          ["name", "label"], ["type", "text"], ["size", "25"],
          ["value", markerRecord.label], // populate input with current label
        ],
      });

      const options = [];
      categories.forEach((categoryInfo, categoryName) => options.push(createElement({
          tag: "option",
          text: categoryName,
          value: categoryName,
          attributes: (categoryName === markerRecord.category) ? [["selected", ""]] : null,
        })
      ));

      const categoryInput = createElement({
        tag: "select",
        attributes: [["name", "category"]],
        children: options,
      });

      const descriptionInput = createElement({
        tag: "textarea",
        text: markerRecord.notes, // populate textarea with current notes
        attributes: [["name", "notes"], ["rows", "4"], ["cols", "20"], ["class", "flexColumn"]],
      });

      // whether there are unsaved changes to the form
      let unsavedChanges = false;
      // the visibility of this element should indicate whether or not there are unsaved changes
      const unsavedNotification = createElement({
        tag: "p",
        text: "You have unsaved changes.",
        attributes: [["class", "unsaved"]],
      });

      // unsaved is a boolean indicating whether or not there are unsaved changes
      function manageUnsavedNotification(unsaved) {
        const unsavedMessage = "You have unsaved changes.";
        unsavedChanges = unsaved;
        unsavedNotification.style.visibility = unsaved ? "visible" : "hidden";
        if (!unsaved) {
          for (const input of [labelInput, categoryInput, descriptionInput]) {
            // alert the user when there are unsaved changes (invoked at most once per element)
            input.addEventListener(
              "input",
              (event) => {
                unsavedChanges = true;
                unsavedNotification.style.visibility = "visible";
              },
              { once : true }
            )
          }
        }
      }

      manageUnsavedNotification(false);

      const closeButton = createElement({
        tag: "button",
        text: "Close",
        attributes: [["type", "button"]],
        eventListeners: [["click", () => {
          if ((!unsavedChanges) || window.confirm("Are you sure you want to close this popup? Your unsaved changes will be lost.")) {
            updateMarkerPopupContent(markerRecord.markerReference, getEditMarkerUI(latlng));
          }
        }]],
      });

      const deleteButton = createElement({
        tag: "button",
        text: "Delete Marker",
        attributes: [["type", "button"], ["class", "warning"]],
        eventListeners: [["click", () => {
          if (window.confirm("Are you sure you want to delete this marker?")) {
            // close popup before deleting it
            markerRecord.markerReference.closePopup();
            // delete marker record
            deleteMarkerRecord(markerRecord.category, latlngString);
            // remove marker from markerLayerGroup
            markerRecord.markerReference.removeFrom(markerLayerGroup);
            }
        }]],
      });

      const saveButton = createElement({
        tag: "button",
        text: "Save Changes",
        attributes: [["type", "button"], ["class", "defaultOption"]],
        eventListeners: [["click", () => {
          const oldCategory = markerRecord.category;
          const newCategory = form.elements["category"].value;
          markerRecord = setMarkerRecord(newCategory, latlngString, {
            markerReference: markerRecord.markerReference, // !!! edit this later to account for case where marker does not exist?
            category: newCategory,
            label: form.elements["label"].value,
            notes: form.elements["notes"].value,
          });
          if (oldCategory !== newCategory) {
            deleteMarkerRecord(oldCategory, latlngString);
            categories.get(oldCategory).layerGroup.removeLayer(markerRecord.markerReference);
            categories.get(newCategory).layerGroup.addLayer(markerRecord.markerReference);
            markerRecord.markerReference.openPopup();
          }
          // update marker color based on selected category
          markerRecord.markerReference.setIcon(generateIcon(categories.get(newCategory).color));
          // reset unsaved changes notification and event listeners
          manageUnsavedNotification(false);
        }]],
      });

      const form = createElement({
        // input for editing marker label
        tag: "form",
        attributes: [["id", "editMarkerForm"], ["class", "editMarkerForm"]],
        children: [
          createElement({
            tag: "p",
            attributes: [["class", "flexRow"]],
            children: [
              createElement({
                tag: "label",
                text: "Label: ",
                children: [
                  labelInput,
                ],
              })
            ]
          }),
          // input for editing category
          createElement({
            tag: "p",
            children: [
              createElement({
                tag: "label",
                text: "Category: ",
                children: [
                  categoryInput,
                ],
              })
            ]
          }),
          // textarea for editing marker notes
          createElement({
            tag: "p",
            children: [
              createElement({
                tag: "label",
                text: "Notes:",
                attributes: [["class", "flexColumn"]],
                children: [
                  descriptionInput,
                ],
              }),
            ],
          }),
          unsavedNotification,
          createElement({
            tag: "div",
            attributes: [["class", "flexRow"]],
            children: [
              closeButton,
              deleteButton,
              saveButton,
            ]
          }),
        ]
      });
      return form;
    }

    function getDefaultMarkerRecord(markerReference) {
      return {
        markerReference: markerReference,
        category: "Unsorted",
        label: "Unnamed Marker",
        notes: "",
      }
    }

    /**
     * Function to run whenever the map is clicked.
     */
    function onMapClick(event) {
      const latlngString = JSON.stringify(event.latlng);
      // if a marker with these coordinates has already been added to the map, open its popup
      // otherwise, add a marker to the map at these coordinates
      /*const markerRecord = getMarkerRecord(latlngString);
      if (markerRecord) {
        markerRecord.markerReference.openPopup();
      } else {*/
        const popup = L.popup({
          closeButton : false,
          autoClose : false,
          closeOnEscapeKey : false,
          closeOnClick : false,
        });
        const defaultGroup = "Unsorted";
        // create marker
        const marker = L.marker(event.latlng, {
          icon : generateIcon(categories.get(defaultGroup).color),
        });
        // add marker record
        setMarkerRecord(defaultGroup, latlngString, getDefaultMarkerRecord(marker));
        // add marker to map
        popup.setContent(getEditMarkerUI(event.latlng));
        marker
          .bindPopup(popup)
          .addTo(categories.get(defaultGroup).layerGroup)
          .openPopup();
      //}
    }

    // add click event listener to map
    map.on("click", onMapClick);
    
    /*document.getElementById("controlButtons").appendChild(createButton("Clear markerRecords", () => {
      // also reset markerRecords set
      markerLayerGroup.clearLayers();
      markerRecords.clear();
      console.log("markerLayerGroup cleared");
    }));*/

    // TODO: consider making markerRecords draggable (would have to add "move" event listener)
  </script>   

</body>

</html>
<!-- references:
  https://github.com/Leaflet/Leaflet/tree/main/docs/examples (BSD 2-Clause license)
  https://stackoverflow.com/a/59052053 (CC BY-SA 4.0 license)
-->
